-- Macaulay2 algorithm for finding a greedy lower bound for the spreading number
-- v0.3
-- Ben Babcock <bababcoc@lakeheadu.ca>
------------------------------------------------------------------------------

needsPackage "EdgeIdeals";

--debuggingMode = false;
getMaxIndepSet = method();

Spread = (n,d) -> (
	if n == 1 or d == 1 then return 1;
	if d == 2 then return n;

	k := binomial(d + n - 1, n - 1);
	x := local x;
	z := local z;

	S := QQ[x_1..x_n];
	T := QQ[z_1..z_k];

	singletons := apply(gens S, i -> i^d);
	W := {};

	-- In the ring S, first determine all monomials of degree D. Second,
	-- determine which pair of monomials have a LCM of degree D+1

	monoS := (monomialIdeal(gens S))^d;
	Sd := flatten entries gens monoS;
	Pairs := {};
	for i from 1 to k do (
		if any(singletons, q -> q == Sd#(i - 1)) then W = append(W, z_i);
		for j from (i + 1) to k do (
			m := lcm(Sd#(i - 1), Sd#(j - 1));
			degm := first degree m;
			if degm == d + 1 then Pairs = append(Pairs,{z_i, z_j});
		);
	);

	-- Build the graph of S_n(d) from the list of monomial pairs
	return getMaxIndepSet(graph(T,Pairs),{});
)

getMaxIndepSet(Graph, List) := (G,W) -> (
	use ring G;

	-- If we didn't get an initial independent set, construct one.
	if #W == 0 then W = buildIndepSet(G, vertices G, {})
	else if not isSubset(W, vertices G) then error "Expected second argument to be a list of vertices.";
	m := product W;

	print ("The current set is: " | toString W);

	I := edgeIdeal G;
	M := monomialIdeal m;
	J := I : M;

	-- If J is the unit ideal, the set isn't independent!	
	if J == ring G then error "Expected an independent set.";

	-- If J is generated by monomials of degree 1, we may be done.
	possiblyMaximal := false;
	if max(apply(degrees J, i->i#0)) == 1 then possiblyMaximal = true;

	-- First we find all vertices not in the neighbourhood of W.  If this list has
	-- one element, we add it to the set before saying we are done.
	newVertices := toList(set(select(vertices G, i -> degreeVertex(G, i) > 0)) - (W | neighbors(G, W)));

	if possiblyMaximal and #newVertices == 0 then return #W;
	if possiblyMaximal and #newVertices == 1 then return(#W + 1);

	-- Otherwise, we induce a subgraph on the new list of vertices.
	H := inducedGraph(G, newVertices, OriginalRing => true);

	-- Select a random vertex of H and build a new independent set
	V = buildIndepSet(H, newVertices, {});

	return getMaxIndepSet(H, W | V);
	);

	buildIndepSet = method();

	buildIndepSet(Graph, List, List) := (G,L,I) -> (
	v := first L;

	if #I == 0 then v = L#(random(0, #L - 1))
	else (
		-- From the remaining vertices, select the vertex with the smallest degree.
		-- This way, we are choosing the vertex that will have the "lowest impact" 
		-- on the number of vertices removed from contention.
		for i from 1 when i < #L do (
			if degreeVertex(G, L#i) < degreeVertex(G, v) then v = L#i;
		);
	);
	I = append(I, v);

	-- Remove any vertices adjacent to v from L
	L = toList(set(L) - ({v} | neighbors(G,v)));

	-- Are there any vertices left?
	if #L == 0 then return I;

	return buildIndepSet(G,L,I);
);